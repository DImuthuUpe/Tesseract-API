<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Tesseract: UnicityTable&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>UnicityTable&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="UnicityTable" -->
<p><code>#include &lt;<a class="el" href="unicity__table_8h_source.html">unicity_table.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UnicityTable&lt; T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_unicity_table.png" usemap="#UnicityTable&lt; T &gt;_map" alt=""/>
  <map id="UnicityTable&lt; T &gt;_map" name="UnicityTable&lt; T &gt;_map">
<area href="class_unicity_table_eq_eq.html" alt="UnicityTableEqEq&lt; T &gt;" shape="rect" coords="0,56,140,80"/>
</map>
 </div>
</div>

<p><a href="class_unicity_table-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#ad2cf3104bf7e0b115d3709359e57cc72">UnicityTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a98181de03a916ae28b9443a8821e90a5">~UnicityTable</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the structures and deallocate internal structures.  <a href="#a98181de03a916ae28b9443a8821e90a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#aed48975fff77cc08f4724edd62e52b2e">reserve</a> (int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a834de17f090dcfcc6625b01c5a627c2f">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size used.  <a href="#a834de17f090dcfcc6625b01c5a627c2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a3b3107bc72d9edfe501eaba7404de7eb">get</a> (int id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the object from an id.  <a href="#a3b3107bc72d9edfe501eaba7404de7eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a6913a3f4f880861e0eca6c606e47646a">get_mutable</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a4820bb7a54cf6ecda86856161c6d5a2f">get_id</a> (T object) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#ae2ca9cd7a9bf7837306df260c218772b">contains</a> (T object) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if T is in the table.  <a href="#ae2ca9cd7a9bf7837306df260c218772b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a327b95e35d5624c791467a63860b6c6b">contains_id</a> (int id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the id is valid.  <a href="#a327b95e35d5624c791467a63860b6c6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a659534293ab0e46a46cab4421bebfb8f">push_back</a> (T object)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element in the table.  <a href="#a659534293ab0e46a46cab4421bebfb8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#accc4dcfc4923d6ec2cb0f19c9f21ecfb">set_clear_callback</a> (<a class="el" href="class_tess_callback1.html">TessCallback1</a>&lt; T &gt; *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a7e1ff22ed9e31fd303ce9fea4f1eeff2">set_compare_callback</a> (<a class="el" href="class_tess_result_callback2.html">TessResultCallback2</a>&lt; bool, T const &amp;, T const &amp; &gt; *cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a43dd3813d75e38232c26e5532b9a096f">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a18c8fc9ccbd7c0befdae1ab65bafdb12">move</a> (<a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt; *from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a23b683e4ea0132af3004552f5d515d61">write</a> (FILE *f, <a class="el" href="class_tess_result_callback2.html">TessResultCallback2</a>&lt; bool, FILE *, T const &amp; &gt; *cb) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicity_table.html#a31e2edb3f92024b211332a850723d237">read</a> (FILE *f, <a class="el" href="class_tess_result_callback3.html">TessResultCallback3</a>&lt; bool, FILE *, T *, bool &gt; *cb, bool swap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap is used to switch the endianness.  <a href="#a31e2edb3f92024b211332a850723d237"></a><br/></td></tr>
</table>
<h3>template&lt;typename T&gt;<br/>
 class UnicityTable&lt; T &gt;</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad2cf3104bf7e0b115d3709359e57cc72"></a><!-- doxytag: member="UnicityTable::UnicityTable" ref="ad2cf3104bf7e0b115d3709359e57cc72" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::<a class="el" href="class_unicity_table.html">UnicityTable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98181de03a916ae28b9443a8821e90a5"></a><!-- doxytag: member="UnicityTable::~UnicityTable" ref="a98181de03a916ae28b9443a8821e90a5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::~<a class="el" href="class_unicity_table.html">UnicityTable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the structures and deallocate internal structures. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a43dd3813d75e38232c26e5532b9a096f"></a><!-- doxytag: member="UnicityTable::clear" ref="a43dd3813d75e38232c26e5532b9a096f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear the table, calling the callback function if any. All the owned Callbacks are also deleted. If you don't want the Callbacks to be deleted, before calling clear, set the callback to NULL. </p>

</div>
</div>
<a class="anchor" id="ae2ca9cd7a9bf7837306df260c218772b"></a><!-- doxytag: member="UnicityTable::contains" ref="ae2ca9cd7a9bf7837306df260c218772b" args="(T object) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if T is in the table. </p>

</div>
</div>
<a class="anchor" id="a327b95e35d5624c791467a63860b6c6b"></a><!-- doxytag: member="UnicityTable::contains_id" ref="a327b95e35d5624c791467a63860b6c6b" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::contains_id </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the id is valid. </p>

</div>
</div>
<a class="anchor" id="a3b3107bc72d9edfe501eaba7404de7eb"></a><!-- doxytag: member="UnicityTable::get" ref="a3b3107bc72d9edfe501eaba7404de7eb" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the object from an id. </p>

</div>
</div>
<a class="anchor" id="a4820bb7a54cf6ecda86856161c6d5a2f"></a><!-- doxytag: member="UnicityTable::get_id" ref="a4820bb7a54cf6ecda86856161c6d5a2f" args="(T object) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::get_id </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the id of the T object. This method NEEDS a compare_callback to be passed to set_compare_callback. </p>

</div>
</div>
<a class="anchor" id="a6913a3f4f880861e0eca6c606e47646a"></a><!-- doxytag: member="UnicityTable::get_mutable" ref="a6913a3f4f880861e0eca6c606e47646a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::get_mutable </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18c8fc9ccbd7c0befdae1ab65bafdb12"></a><!-- doxytag: member="UnicityTable::move" ref="a18c8fc9ccbd7c0befdae1ab65bafdb12" args="(UnicityTable&lt; T &gt; *from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt; *&nbsp;</td>
          <td class="paramname"> <em>from</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method clear the current object, then, does a shallow copy of its argument, and finally invalidate its argument. </p>

</div>
</div>
<a class="anchor" id="a659534293ab0e46a46cab4421bebfb8f"></a><!-- doxytag: member="UnicityTable::push_back" ref="a659534293ab0e46a46cab4421bebfb8f" args="(T object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an element in the table. </p>

</div>
</div>
<a class="anchor" id="a31e2edb3f92024b211332a850723d237"></a><!-- doxytag: member="UnicityTable::read" ref="a31e2edb3f92024b211332a850723d237" args="(FILE *f, TessResultCallback3&lt; bool, FILE *, T *, bool &gt; *cb, bool swap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tess_result_callback3.html">TessResultCallback3</a>&lt; bool, FILE *, T *, bool &gt; *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>swap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>swap is used to switch the endianness. </p>

</div>
</div>
<a class="anchor" id="aed48975fff77cc08f4724edd62e52b2e"></a><!-- doxytag: member="UnicityTable::reserve" ref="aed48975fff77cc08f4724edd62e52b2e" args="(int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve some memory. If there is size or more elements, the table will then allocate size * 2 elements. </p>

</div>
</div>
<a class="anchor" id="accc4dcfc4923d6ec2cb0f19c9f21ecfb"></a><!-- doxytag: member="UnicityTable::set_clear_callback" ref="accc4dcfc4923d6ec2cb0f19c9f21ecfb" args="(TessCallback1&lt; T &gt; *cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::set_clear_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tess_callback1.html">TessCallback1</a>&lt; T &gt; *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a callback to be called to delete the elements when the table took their ownership. </p>

</div>
</div>
<a class="anchor" id="a7e1ff22ed9e31fd303ce9fea4f1eeff2"></a><!-- doxytag: member="UnicityTable::set_compare_callback" ref="a7e1ff22ed9e31fd303ce9fea4f1eeff2" args="(TessResultCallback2&lt; bool, T const &amp;, T const &amp; &gt; *cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::set_compare_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tess_result_callback2.html">TessResultCallback2</a>&lt; bool, T const &amp;, T const &amp; &gt; *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a callback to be called to compare the elements when needed (contains, get_id, ...) </p>

</div>
</div>
<a class="anchor" id="a834de17f090dcfcc6625b01c5a627c2f"></a><!-- doxytag: member="UnicityTable::size" ref="a834de17f090dcfcc6625b01c5a627c2f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size used. </p>

</div>
</div>
<a class="anchor" id="a23b683e4ea0132af3004552f5d515d61"></a><!-- doxytag: member="UnicityTable::write" ref="a23b683e4ea0132af3004552f5d515d61" args="(FILE *f, TessResultCallback2&lt; bool, FILE *, T const &amp; &gt; *cb) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_unicity_table.html">UnicityTable</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tess_result_callback2.html">TessResultCallback2</a>&lt; bool, FILE *, T const &amp; &gt; *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read/Write the table to a file. This does _NOT_ read/write the callbacks. The Callback given must be permanent since they will be called more than once. The given callback will be deleted at the end. Returns false on read/write error. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/rays/src/opensrc/tesseract-ocr/ccutil/<a class="el" href="unicity__table_8h_source.html">unicity_table.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Feb 2 08:19:25 2012 for Tesseract by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
